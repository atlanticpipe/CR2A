name: Checksums Build

on:
  workflow_dispatch: {}
  push:
    branches: [ main, branch ]
  pull_request:
    branches: [ main ]

permissions:
  contents: write # required to push with GitHub_Token
jobs:
  build-checksums:
    runs-on: ubuntu-latest
    env:
      MAN: contract-analysis-policy-bundle/policy/checksums_manifest_v1.json
    
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}    # checks out the branch the workflow is running on

      - name: Install jq
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Debug current manifest (if present)
        shell: bash
        run: |
          set -euo pipefail
          if [ -f "$MAN" ]; then
            echo "Found $MAN:"
            sed -n '1,120p' "$MAN"
            echo
            echo "jq parse check:"
            jq -e . "$MAN" || echo ">> jq failed parsing manifest"
          else
            echo "No manifest file found."
          fi
          
      - name: Bootstrap manifest if missing
        shell: bash
        run: |
          set -euo pipefail
          : "${MAN:?MAN env var must be set}"
          MAN_DIR="$(dirname "$MAN")"
          mkdir -p "$MAN_DIR"
          # If file doesn't exist OR jq parse fails, bootstrap a fresh manifest
          if [ ! -f "$MAN" ] || ! jq -e "$MAN" >/dev/null 2>1; then
            # Use printf instead of heredoc to avoid YAML/heredoc edge cases
            printf '%s\n' \
              '{' \
              '  "manifest_version": "1.0",' \
              '  "generated_at": "1970-01-01T00:00:00Z",' \
              '  "manifest_sha256": "",' \
              '  "artifacts": []' \
              '}' >"$MAN"
          fi
          # Final sanity check
          jq -e . "$MAN" >/dev/null

      - name: Update artifact size_bytes and sha256
        run: |
          set -euo pipefail
          TMP="$(mktemp)"
          jq -e . "$MAN" >/dev/null

          # Iterate listed artifacts and refresh their size/sha256
          jq -c '.artifacts[]' "$MAN" | while read -r ART; do
            P="$(jq -r '.path'  <<<"$ART")"
            N="$(jq -r '.name'  <<<"$ART")"
            if [ ! -f "$P" ]; then
              echo "Missing artifact file: $P" >&2
              exit 1
            fi
            SIZE="$(stat -c%s "$P")"
            SHA="$(sha256sum "$P" | cut -d' ' -f1)"

            jq --arg p "$P" --arg sz "$SIZE" --arg sha "$SHA" '
              (.artifacts[] | select(.path == $p) | .size_bytes) = ($sz | tonumber)
              | (.artifacts[] | select(.path == $p) | .sha256)    = $sha
            ' "$MAN" > "$TMP" && mv "$TMP" "$MAN"

            echo "Updated $N size_bytes=$SIZE sha256=$SHA"
          done

      - name: Canonicalize manifest & stamp top-level hash
        shell: bash
        run: |
          set -euo pipefail
          # Ensure MAN is provided and file exists
          : "${MAN:?MAN env var is required}"
          test -f "$MAN" || { echo "::error::Manifest not found at $MAN"; exit 1; }
          
          TMP="$(mktemp)"

          # Canonicalize (keys sorted; artifacts sorted by path; drop manifes_sha256)
          CANON="$(jq -S '
            .artifacts |= (sort_by(.path))
            | del(.manifest_sha256)
          ' "$MAN")" || { echo "::error::jq failed to process $MAN"; exit 1;}

          # Compute hash without newline
          CALC="$(printf '%s' "$CANON" | sha256sum)"; CALC="${CALC%% *}"
          echo "canonical manifest_sha256 = $CALC"
          
          # Write back with stamped hash and fresh timestamp
          printf '%s' "$CANON" | jq --arg s "$CALC" '
            .manifest_sha256 = $s
            | .generated_at = (now | todateiso8601)
          ' > "STMP"
          mv "$TMP" "$MAN"

      - name: Assert manifest exists
        shell: bash
        run: |
          set -euo pipefail
          if [[ -f "$MAN" ]]; then
            echo "Manifest present at $MAN"
          else
            echo "::error ::Manifest not found at $MAN"
            ls -la "$(dirname "$MAN")" || true
            exit 1
          fi
          
      - name: Show diff
        run: |
          set -euo pipefail
          git diff -- "$MAN" || true

      - name: Commit and push if changed
        shell: bash
        env:
          FILE: contract-analysis-policy-bundle/policy/checksums_manifest_v1.json
        run: |
          set -euo pipefail
          
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Did we actually change the manifest?
          if git diff --quiet -- "$FILE"; then
            echo "No changes to commit."
            # Keep the branch up to date anyway (non-fatal if nothing to pull)
            git fetch origin "${GITHUB_REF_NAME}" || true
            git pull --rebase origin "${GITHUB_REF_NAME}" || true
            exit 0
          fi

          echo "Local manifes updated; preparing to rebase..."
          # Save the local change so we can rebase cleanly
          git stash push -u -m "ci-stash" >/dev/null 2>&1 || true

          git fetch origin "${GITHUB_REF_NAME}"
          git checkout "${GITHUB_REF_NAME}"
          git pull --rebase origin "${GITHUB_REF_NAME}"

          # Restore our change on top of the rebased branch
          git stash pop >/dev/null 2>&1 || true

          # Stage, commit, and push
          git add -- "$FILE"
          git commit -m "ci: rebuild checksums manifest auto"
          git push origin HEAD:"${GITHUB_REF_NAME}"
          echo "Pushed updated manifest."
