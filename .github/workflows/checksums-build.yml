name: Checksums Build

on:
  workflow_dispatch: {}
  push:
    branches: [ main, branch ]
  pull_request:
    branches: [ main ]

permissions:
  contents: write # required to push with GITHUB_TOKEN
  
jobs:
  build-checksums:
    runs-on: ubuntu-latest
    env:
      MAN: contract-analysis-policy-bundle/policy/checksums_manifest_v1.json
    
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}    # checks out the branch the workflow is running on

      - name: Install jq
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Debug current manifest (if present)
        shell: bash
        run: |
          set -euo pipefail
          if [ -f "$MAN" ]; then
            echo "Found $MAN:"
            sed -n '1,120p' "$MAN"
            echo
            echo "jq parse check:"
            jq -e . "$MAN" || echo ">> jq failed parsing manifest"
          else
            echo "No manifest file found."
          fi

      - name: Update canonical size_bytes and sha256
        run: |
          set -euo pipefail
          TMP="$(mktemp)"
          jq -e . "$MAN" >/dev/null

          # Iterate listed canonical and refresh their size/sha256
          jq -c '.canonical[]' "$MAN" | while read -r ART; do
            P="$(jq -r '.path'  <<<"$ART")"
            N="$(jq -r '.name'  <<<"$ART")"
            if [ ! -f "$P" ]; then
              echo "Missing canonical file: $P" >&2
              exit 1
            fi
            SIZE="$(stat -c%s "$P")"
            SHA="$(sha256sum "$P" | cut -d' ' -f1)"

            jq --arg p "$P" --arg sz "$SIZE" --arg sha "$SHA" '
              (.canonical[] | select(.path == $p) | .size_bytes) = ($sz | tonumber)
              | (.canonical[] | select(.path == $p) | .sha256)    = $sha
            ' "$MAN" > "$TMP" && mv "$TMP" "$MAN"

            echo "Updated $N size_bytes=$SIZE sha256=$SHA"
          done

      - name: Canonicalize manifest & stamp top-level hash
        shell: bash
        run: |
          set -euo pipefail
          # Ensure MAN is provided and file exists
          : "${MAN:?MAN env var is required}"
          test -f "$MAN" || { echo "::error::Manifest not found at $MAN"; exit 1; }
          
          TMP="$(mktemp)"

          # Canonicalize (keys sorted; canonical sorted by path; drop manifes_sha256)
          CANON="$(jq -S '
            .canonical |= (sort_by(.path))
            | del(.manifest_sha256)
          ' "$MAN")" || { echo "::error::jq failed to process $MAN"; exit 1;}

          # Compute hash without newline
          CALC="$(printf '%s' "$CANON" | sha256sum)"; CALC="${CALC%% *}"
          echo "canonical manifest_sha256 = $CALC"
          
          # Write back with stamped hash and fresh timestamp
          printf '%s' "$CANON" | jq --arg s "$CALC" '
            .manifest_sha256 = $s
            | .generated_at = (now | todateiso8601)
          ' > "STMP"
          mv "$TMP" "$MAN"

      - name: Assert manifest exists
        shell: bash
        run: |
          set -euo pipefail
          if [[ -f "$MAN" ]]; then
            echo "Manifest present at $MAN"
          else
            echo "::error ::Manifest not found at $MAN"
            ls -la "$(dirname "$MAN")" || true
            exit 1
          fi
          
      - name: Show diff
        run: |
          set -euo pipefail
          git diff -- "$MAN" || true

      - name: Commit and push if changed
        shell: bash
        env:
          FILE: contract-analysis-policy-bundle/policy/checksums_manifest_v1.json
        run: |
          set -euo pipefail
          
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Did we actually change the manifest?
          if git diff --quiet -- "$FILE"; then
            echo "No changes to commit."
            # Keep the branch up to date anyway (non-fatal if nothing to pull)
            git fetch origin "${GITHUB_REF_NAME}" || true
            git pull --rebase origin "${GITHUB_REF_NAME}" || true
            exit 0
          fi
