# ======================================================================
# Policy Validate ‚Äî repo smoke + integrity gates
# - Proves CI is wired
# - Cross-checks version lock ‚Üî checksums manifest
# - (Optional) Enforces tag and sha256 if lock says to
# ======================================================================

name: Policy Validate

on:
  push:
    branches: [ main ]          # Run on pushes to main
  pull_request:
    branches: [ main ]          # And on PRs targeting main

jobs:
  validate:
    runs-on: ubuntu-latest

    steps:
      # 1) Checkout repo so we can read files
      - name: Checkout
        uses: actions/checkout@v4

      # 2) Install jq (we use it to parse JSON)
      - name: Install jq
        run: sudo apt-get update -y && sudo apt-get install -y jq

      # 3) Quick tree for debug
      - name: Print repo tree (debug)
        run: |
          echo "::group::TREE"
          ls -la
          echo
          echo "Recursive:"
          ls -R
          echo "::endgroup::"

            # 4) Ensure the checksums manifest is fresh relative to latest file changes
      - name: Check checksums manifest freshness
        run: |
          set -euo pipefail
          MAN="contract-analysis-policy-bundle/policy/checksums_manifest_v1.json"

          # Tolerance: allow up to 10 minutes of skew between commits and manifest generation
          ALLOWED_LAG_SEC=600

          # Parse manifest generated_at (UTC) ‚Üí epoch seconds
          GEN_STR=$(jq -r '.generated_at // empty' "$MAN")
          if [ -z "$GEN_STR" ]; then
            echo "‚ùå Manifest missing .generated_at" >&2
            exit 1
          fi
          GEN_EPOCH=$(date -u -d "$GEN_STR" +%s || true)
          if [ -z "${GEN_EPOCH:-}" ]; then
            echo "‚ùå Unable to parse manifest .generated_at='$GEN_STR'" >&2
            exit 1
          fi

          # Build list of artifact paths from manifest, then find latest commit time touching any of them
          mapfile -t PATHS < <(jq -r '.artifacts[].path' "$MAN" | sort -u)
          if [ "${#PATHS[@]}" -eq 0 ]; then
            echo "‚ùå No artifacts listed in manifest" >&2
            exit 1
          fi

          LATEST_CT=0
          for p in "${PATHS[@]}"; do
            # If a file is new and has no commits yet, fall back to '0' silently
            CT=$(git log -1 --format=%ct -- "$p" || echo 0)
            [ -z "$CT" ] && CT=0
            if [ "$CT" -gt "$LATEST_CT" ]; then
              LATEST_CT="$CT"
              LATEST_PATH="$p"
            fi
          done

          echo "Manifest generated_at: $GEN_STR  (epoch=$GEN_EPOCH)"
          echo "Latest artifact commit: $(date -u -d @${LATEST_CT} +'%Y-%m-%dT%H:%M:%SZ') (epoch=$LATEST_CT)  path=${LATEST_PATH:-n/a}"

          # Fail if manifest is older than the latest artifact change beyond tolerance
          if [ $(( GEN_EPOCH + ALLOWED_LAG_SEC )) -lt "$LATEST_CT" ]; then
            echo "‚ùå Manifest is stale (older than latest change + ${ALLOWED_LAG_SEC}s tolerance)." >&2
            echo "   Run the checksums build or push a commit that updates the manifest." >&2
            exit 1
          fi

          echo "‚úÖ Manifest freshness OK within ${ALLOWED_LAG_SEC}s tolerance."

      
      # 4) Cross-check that every component path in version_lock exists in manifest
      - name: Cross-check version_lock ‚Üî checksums_manifest (paths)
        run: |
          set -euo pipefail
          LOCK="contract-analysis-policy-bundle/policy/version_lock.schemas_v1.json"
          MAN="contract-analysis-policy-bundle/policy/checksums_manifest_v1.json"

          # Collect manifest paths to an array
          mapfile -t MAN_PATHS < <(jq -r '.artifacts[].path' "$MAN" | sort -u)

          # Verify each lock path is present in manifest paths
          jq -r '.components[].path' "$LOCK" | while read -r P; do
            if ! printf '%s\n' "${MAN_PATHS[@]}" | grep -Fx "$P" >/dev/null; then
              echo "‚ùå Missing in checksums_manifest: $P" >&2
              exit 1
            fi
          done

          echo "‚úÖ version_lock and checksums_manifest have matching paths."

      # 5) If the lock says to enforce sha256, compare hashes component-by-component
      - name: Enforce sha256 digests when enabled
        run: |
          set -euo pipefail
          LOCK="contract-analysis-policy-bundle/policy/version_lock.schemas_v1.json"
          MAN="contract-analysis-policy-bundle/policy/checksums_manifest_v1.json"

          ENFORCE=$(jq -r '.meta.enforce_sha256 // .enforcement.enforce_sha256 // false' "$LOCK")
          if [ "$ENFORCE" != "true" ]; then
            echo "‚ÑπÔ∏è  meta.enforce_sha256=false ‚Äî skipping digest enforcement."
            exit 0
          fi

          # For each component in lock, find the same path in manifest and compare sha256
          jq -c '.components[]' "$LOCK" | while read -r COMP; do
            NAME=$(jq -r '.name'   <<<"$COMP")
            PATHF=$(jq -r '.path'  <<<"$COMP")
            LOCK_SHA=$(jq -r '.sha256 // ""' <<<"$COMP")

            # Pull sha from manifest by path
            MAN_SHA=$(jq -r --arg p "$PATHF" '.artifacts[] | select(.path == $p) | .sha256 // ""' "$MAN")

            if [ -z "$LOCK_SHA" ] || [ -z "$MAN_SHA" ]; then
              echo "‚ùå Missing sha256 for $NAME ($PATHF) ‚Äî lock:'$LOCK_SHA' manifest:'$MAN_SHA'" >&2
              exit 1
            fi

            if [ "$LOCK_SHA" != "$MAN_SHA" ]; then
              echo "‚ùå sha256 mismatch for $NAME ($PATHF)" >&2
              echo "   lock:     $LOCK_SHA" >&2
              echo "   manifest: $MAN_SHA" >&2
              exit 1
            fi

            echo "‚úÖ $NAME digest OK"
          done

          echo "‚úÖ All digests match (enforcement enabled)."

      # 6) (Optional) Require bundle tag to be the expected value
      - name: Verify bundle tag (optional)
        env:
          EXPECTED_TAG: "schemas@v1.0"      # <- update when you bump the bundle
        run: |
          set -euo pipefail
          LOCK="contract-analysis-policy-bundle/policy/version_lock.schemas_v1.json"
          TAG=$(jq -r '.tag // ""' "$LOCK")
          if [ -z "$TAG" ]; then
            echo "‚ùå version_lock missing .tag" >&2
            exit 1
          fi
          if [ "$TAG" != "$EXPECTED_TAG" ]; then
            echo "‚ùå version_lock tag '$TAG' != expected '$EXPECTED_TAG'" >&2
            exit 1
          fi
          echo "‚úÖ Bundle tag OK: $TAG"

      # 7) Success marker so we get a clear green check when all gates pass
      - name: Success marker
        run: echo "üéâ Policy validation passed."
