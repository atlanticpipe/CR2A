<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Contract Analysis Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .main-content {
            padding: 40px;
        }

        .settings-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 30px;
            border-left: 4px solid #667eea;
        }

        .settings-section h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.3em;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }

        .form-group input, .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus, .form-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .drop-zone {
            border: 3px dashed #cbd5e0;
            border-radius: 10px;
            padding: 60px 40px;
            text-align: center;
            background: #f8f9fa;
            transition: all 0.3s ease;
            cursor: pointer;
            margin-bottom: 30px;
        }

        .drop-zone:hover {
            border-color: #667eea;
            background: #eef2ff;
        }

        .drop-zone.drag-over {
            border-color: #667eea;
            background: #e6f3ff;
        }

        .drop-zone-icon {
            font-size: 48px;
            color: #a0aec0;
            margin-bottom: 15px;
        }

        .drop-zone-text {
            color: #4a5568;
            font-size: 18px;
            margin-bottom: 10px;
        }

        .drop-zone-subtext {
            color: #718096;
            font-size: 14px;
        }

        .file-list {
            margin-top: 20px;
        }

        .file-item {
            background: white;
            border: 1px solid #e1e8ed;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-info {
            display: flex;
            align-items: center;
        }

        .file-icon {
            font-size: 20px;
            margin-right: 10px;
        }

        .file-name {
            font-weight: 500;
        }

        .file-size {
            color: #718096;
            font-size: 14px;
            margin-left: 10px;
        }

        .remove-file {
            background: #fed7d7;
            color: #e53e3e;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 16px;
        }

        .process-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 15px 40px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease;
            width: 100%;
            margin-bottom: 20px;
        }

        .process-btn:hover {
            transform: translateY(-2px);
        }

        .process-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }

        .status.loading {
            background: #ebf8ff;
            border: 1px solid #bee3f8;
            color: #2b6cb0;
        }

        .status.success {
            background: #f0fff4;
            border: 1px solid #9ae6b4;
            color: #276749;
        }

        .status.error {
            background: #fed7d7;
            border: 1px solid #feb2b2;
            color: #c53030;
        }

        .progress-container {
            margin-bottom: 20px;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e1e8ed;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            text-align: center;
            margin-top: 8px;
            font-size: 14px;
            color: #4a5568;
        }

        .download-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 25px;
            text-align: center;
            display: none;
        }

        .download-btn {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 15px 40px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            margin: 10px;
        }

        .download-btn:hover {
            transform: translateY(-2px);
        }

        .template-customization {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 30px;
        }

        .template-customization h3 {
            color: #2c3e50;
            margin-bottom: 15px;
        }

        .template-customization textarea {
            min-height: 100px;
            font-family: 'Courier New', monospace;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 10px;
            }

            .header {
                padding: 20px;
            }

            .header h1 {
                font-size: 2em;
            }

            .main-content {
                padding: 20px;
            }

            .drop-zone {
                padding: 40px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Contract Analysis Tool</h1>
            <p>Upload contract documents for AI-powered risk analysis and compliance review</p>
        </div>

        <div class="main-content">
            <!-- API Key Section -->
            <div class="settings-section">
                <h2>ðŸ”‘ API Configuration</h2>
                <div class="form-group">
                    <label for="api-key">OpenAI API Key:</label>
                    <input type="password" id="api-key" placeholder="sk-..." />
                </div>
            </div>

            <!-- Template Customization -->
            <div class="settings-section template-customization">
                <h2>ðŸ“‹ Analysis Template</h2>
                <p style="color: #718096; margin-bottom: 15px;">Customize the analysis template or use the default comprehensive contract review template.</p>
                <div class="form-group">
                    <label for="custom-template">Custom Template (JSON Schema):</label>
                    <textarea id="custom-template" placeholder="Leave empty to use default template"></textarea>
                </div>
            </div>

            <!-- File Upload Section -->
            <div class="settings-section">
                <h2>ðŸ“„ Contract Documents</h2>
                <p style="color: #718096; margin-bottom: 20px;">Drag and drop contract files here (PDF, DOC, DOCX, TXT). Multiple files supported.</p>
                
                <div class="drop-zone" id="drop-zone">
                    <div class="drop-zone-icon">ðŸ“‹</div>
                    <div class="drop-zone-text">Drop contract files here</div>
                    <div class="drop-zone-subtext">or click to browse files</div>
                </div>

                <div class="file-list" id="file-list"></div>

                <button class="process-btn" id="process-btn">ðŸš€ Process Contracts</button>
            </div>

            <!-- Progress Section -->
            <div class="progress-container" id="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill"></div>
                </div>
                <div class="progress-text" id="progress-text">Preparing analysis...</div>
            </div>

            <!-- Status Messages -->
            <div class="status" id="status-message"></div>

            <!-- Download Section -->
            <div class="download-section" id="download-section">
                <h3>âœ… Analysis Complete!</h3>
                <p>Your contract analysis report has been generated successfully.</p>
                <button class="download-btn" id="download-btn">ðŸ“¥ Download PDF Report</button>
                <button class="download-btn" onclick="location.reload()">ðŸ”„ Analyze New Contracts</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        // Contract Analysis Web Application
        // Self-contained HTML application for contract analysis and PDF generation

        class ContractAnalyzer {
            constructor() {
                this.files = [];
                this.defaultTemplate = null;
                this.validationRules = null;
                this.initializeEventListeners();
                this.loadDefaultTemplate();
            }

            initializeEventListeners() {
                const dropZone = document.getElementById('drop-zone');
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.multiple = true;
                fileInput.accept = '.pdf,.doc,.docx,.txt';

                // Drop zone events
                dropZone.addEventListener('click', () => fileInput.click());
                dropZone.addEventListener('dragover', this.handleDragOver.bind(this));
                dropZone.addEventListener('dragleave', this.handleDragLeave.bind(this));
                dropZone.addEventListener('drop', this.handleDrop.bind(this));

                // File input events
                fileInput.addEventListener('change', (e) => {
                    this.addFiles(e.target.files);
                    e.target.value = ''; // Reset input
                });

                // Process button
                document.getElementById('process-btn').addEventListener('click', () => {
                    this.processContracts();
                });

                // Download button
                document.getElementById('download-btn').addEventListener('click', () => {
                    this.downloadPDF();
                });
            }

            async loadDefaultTemplate() {
                // Load default schema and validation rules
                this.defaultTemplate = {
                    schema: await this.loadJSON('output_schemas_v1.json'),
                    rules: await this.loadJSON('validation_rules_v1.json')
                };
            }

            async loadJSON(filename) {
                try {
                    const response = await fetch(filename);
                    return await response.json();
                } catch (error) {
                    console.error(`Error loading ${filename}:`, error);
                    return null;
                }
            }

            handleDragOver(e) {
                e.preventDefault();
                e.currentTarget.classList.add('drag-over');
            }

            handleDragLeave(e) {
                e.preventDefault();
                e.currentTarget.classList.remove('drag-over');
            }

            handleDrop(e) {
                e.preventDefault();
                e.currentTarget.classList.remove('drag-over');
                this.addFiles(e.dataTransfer.files);
            }

            addFiles(fileList) {
                Array.from(fileList).forEach(file => {
                    if (this.validateFile(file)) {
                        this.files.push(file);
                        this.renderFileList();
                    }
                });
            }

            validateFile(file) {
                const allowedTypes = [
                    'application/pdf',
                    'application/msword',
                    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                    'text/plain'
                ];

                if (!allowedTypes.includes(file.type)) {
                    this.showStatus('Only PDF, DOC, DOCX, and TXT files are allowed.', 'error');
                    return false;
                }

                if (file.size > 200 * 1024 * 1024) { // 200MB limit
                    this.showStatus(`File ${file.name} is too large. Maximum size is 200MB.`, 'error');
                    return false;
                }

                return true;
            }

            renderFileList() {
                const fileList = document.getElementById('file-list');
                fileList.innerHTML = '';

                this.files.forEach((file, index) => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    
                    const fileIcon = this.getFileIcon(file.type);
                    const fileSize = this.formatFileSize(file.size);
                    
                    fileItem.innerHTML = `
                        <div class="file-info">
                            <span class="file-icon">${fileIcon}</span>
                            <span class="file-name">${file.name}</span>
                            <span class="file-size">(${fileSize})</span>
                        </div>
                        <button class="remove-file" onclick="analyzer.removeFile(${index})">Ã—</button>
                    `;
                    
                    fileList.appendChild(fileItem);
                });
            }

            getFileIcon(fileType) {
                if (fileType.includes('pdf')) return 'ðŸ“„';
                if (fileType.includes('word')) return 'ðŸ“';
                if (fileType.includes('text')) return 'ðŸ“ƒ';
                return 'ðŸ“‹';
            }

            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            removeFile(index) {
                this.files.splice(index, 1);
                this.renderFileList();
            }

            async processContracts() {
                // Clear any previous status
                this.clearStatus();

                const apiKey = document.getElementById('api-key').value.trim();
                if (!apiKey) {
                    this.showStatus('Please enter your OpenAI API key.', 'error');
                    return;
                }

                if (!this.isValidApiKey(apiKey)) {
                    this.showStatus('Please enter a valid OpenAI API key (should start with sk-).', 'error');
                    return;
                }

                if (this.files.length === 0) {
                    this.showStatus('Please select contract files to analyze.', 'error');
                    return;
                }

                // Validate files before processing
                for (const file of this.files) {
                    if (!this.validateFile(file)) {
                        return; // validateFile shows error message
                    }
                }

                this.showStatus('Starting contract analysis...', 'loading');
                this.showProgress(0, 'Reading contract files...');
                this.disableProcessButton(true);

                try {
                    // Read all files with progress tracking
                    const contractTexts = await this.readAllFiles();
                    this.showProgress(25, 'Extracting contract text...');

                    // Combine all contract texts
                    const combinedText = contractTexts.join('\n\n---\n\n');
                    
                    if (!combinedText.trim()) {
                        throw new Error('No readable text content found in uploaded files.');
                    }

                    this.showProgress(50, 'Analyzing contracts with AI...');

                    // Get custom template or use default
                    const customTemplateText = document.getElementById('custom-template').value.trim();
                    let template;
                    
                    if (customTemplateText) {
                        try {
                            const customTemplate = JSON.parse(customTemplateText);
                            template = {
                                schema: customTemplate,
                                rules: this.defaultTemplate?.rules || {}
                            };
                        } catch (parseError) {
                            throw new Error(`Invalid custom template JSON: ${parseError.message}`);
                        }
                    } else {
                        if (!this.defaultTemplate) {
                            throw new Error('Default template not loaded. Please refresh and try again.');
                        }
                        template = this.defaultTemplate;
                    }

                    // Analyze contracts
                    const analysis = await this.analyzeContracts(combinedText, apiKey, template);
                    this.showProgress(75, 'Generating PDF report...');

                    // Validate analysis results
                    if (!this.validateAnalysis(analysis)) {
                        throw new Error('Analysis results failed validation. Please try again.');
                    }

                    // Generate PDF
                    await this.generatePDF(analysis);
                    this.showProgress(100, 'Complete!');

                    this.showStatus('Analysis complete! PDF report generated successfully.', 'success');
                    this.showDownloadSection();

                } catch (error) {
                    console.error('Processing error:', error);
                    this.showStatus(`Error: ${error.message}`, 'error');
                    this.showProgress(0, '');
                } finally {
                    this.disableProcessButton(false);
                }
            }

            isValidApiKey(apiKey) {
                return apiKey.startsWith('sk-') && apiKey.length > 20;
            }

            validateAnalysis(analysis) {
                if (!analysis || typeof analysis !== 'object') {
                    return false;
                }

                // Check for required top-level fields
                const requiredFields = [
                    'schema_version', 'contract_overview', 'administrative_and_commercial_terms',
                    'technical_and_performance_terms', 'legal_risk_and_enforcement',
                    'regulatory_and_compliance_terms', 'data_technology_and_deliverables',
                    'supplemental_operational_risks', 'final_analysis'
                ];

                for (const field of requiredFields) {
                    if (!(field in analysis)) {
                        console.warn(`Missing required field in analysis: ${field}`);
                        return false;
                    }
                }

                return true;
            }

            clearStatus() {
                const statusElement = document.getElementById('status-message');
                statusElement.style.display = 'none';
                statusElement.className = 'status';
            }

            disableProcessButton(disabled) {
                const processBtn = document.getElementById('process-btn');
                processBtn.disabled = disabled;
            }

            async readAllFiles() {
                const contractTexts = [];

                for (const file of this.files) {
                    try {
                        const text = await this.readFile(file);
                        contractTexts.push(`=== ${file.name} ===\n${text}`);
                    } catch (error) {
                        throw new Error(`Failed to read ${file.name}: ${error.message}`);
                    }
                }

                return contractTexts;
            }

            async readFile(file) {
                return new Promise(async (resolve, reject) => {
                    try {
                        if (file.type === 'application/pdf') {
                            // Use PDF.js for PDF text extraction
                            await this.extractPDFText(file, resolve, reject);
                        } else if (file.type.includes('text')) {
                            // Handle text files
                            const reader = new FileReader();
                            reader.onload = (e) => resolve(e.target.result);
                            reader.onerror = () => reject(new Error('Failed to read text file'));
                            reader.readAsText(file);
                        } else if (file.type.includes('word') || file.type.includes('document')) {
                            // For Word documents, provide a placeholder for now
                            // In a full implementation, you'd use a library like mammoth.js
                            resolve(`Word Document: ${file.name}\n\n[Note: Word document text extraction requires additional processing library]`);
                        } else {
                            reject(new Error(`Unsupported file type: ${file.type}`));
                        }
                    } catch (error) {
                        reject(new Error(`Error reading ${file.name}: ${error.message}`));
                    }
                });
            }

            async extractPDFText(file, resolve, reject) {
                try {
                    // Configure PDF.js worker
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                    
                    const arrayBuffer = await file.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                    
                    let fullText = '';
                    const numPages = pdf.numPages;
                    
                    // Extract text from all pages
                    for (let pageNum = 1; pageNum <= numPages; pageNum++) {
                        try {
                            const page = await pdf.getPage(pageNum);
                            const textContent = await page.getTextContent();
                            const pageText = textContent.items.map(item => item.str).join(' ');
                            fullText += `--- Page ${pageNum} ---\n${pageText}\n\n`;
                        } catch (pageError) {
                            console.warn(`Error extracting text from page ${pageNum}:`, pageError);
                            fullText += `--- Page ${pageNum} ---\n[Error extracting text from this page]\n\n`;
                        }
                    }
                    
                    resolve(fullText.trim());
                } catch (error) {
                    reject(new Error(`PDF text extraction failed: ${error.message}`));
                }
            }

            async analyzeContracts(contractText, apiKey, template) {
                try {
                    // Prepare the request payload
                    const schemaContent = JSON.stringify(template.schema || this.defaultTemplate.schema);
                    const rulesContent = JSON.stringify(template.rules || this.defaultTemplate.rules);

                    // Create the system and user messages
                    const systemMessage = `You are a Contract Analysis Engine. Output only a single JSON object that conforms exactly to the provided JSON Schema (2020-12). Do not include explanations or extra keys. If a required data point is not present in the contract, use "" for strings or [] for arrays. For each ClauseBlock, include at least one Redline Recommendations item with an action of insert, replace, or delete.`;

                    const userMessage = `SCHEMA (do not echo): <<<JSON_SCHEMA_START
${schemaContent}
JSON_SCHEMA_END>>>

COMPANY RULES (do not echo; you must comply): <<<RULES_START
${rulesContent}
RULES_END>>>

TEMPLATE HEADINGS (for your reference only; do not echo):
I. Contract Overview
II. Administrative & Commercial Terms
III. Technical & Performance Terms
IV. Legal Risk & Enforcement
V. Regulatory & Compliance Terms
VI. Data, Technology & Deliverables
VII. Supplemental Operational Risks
VIII. Final Analysis

CONTRACT TEXT:
<<<CONTRACT_START
${contractText}
CONTRACT_END>>>

Produce ONLY the JSON object that conforms to the schema above. No comments, no markdown, no prose.`;

                    // Make API call to OpenAI
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-5',
                            input: buildPromptFromInputs
                            temperature: 0.2,
                            max_completion_tokens: 250000,
                            response_format: { type: 'json_object' }
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`OpenAI API error: ${errorData.error?.message || 'Unknown error'}`);
                    }

                    const data = await response.json();
                    
                    if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                        throw new Error('Invalid response format from OpenAI API');
                    }

                    const content = data.choices[0].message.content;
                    
                    if (!content) {
                        throw new Error('Empty response from OpenAI API');
                    }

                    // Parse and validate the JSON response
                    let analysis;
                    try {
                        analysis = JSON.parse(content);
                    } catch (parseError) {
                        throw new Error(`Invalid JSON response from API: ${parseError.message}`);
                    }

                    // Validate that the response conforms to the expected structure
                    if (!analysis || typeof analysis !== 'object') {
                        throw new Error('Response is not a valid object');
                    }

                    // Ensure required fields are present
                    const requiredFields = [
                        'schema_version', 'contract_overview', 'administrative_and_commercial_terms',
                        'technical_and_performance_terms', 'legal_risk_and_enforcement',
                        'regulatory_and_compliance_terms', 'data_technology_and_deliverables',
                        'supplemental_operational_risks', 'final_analysis'
                    ];

                    for (const field of requiredFields) {
                        if (!(field in analysis)) {
                            console.warn(`Missing required field: ${field}`);
                            analysis[field] = field === 'supplemental_operational_risks' ? [] : {};
                        }
                    }

                    return analysis;

                } catch (error) {
                    if (error.message.includes('API error')) {
                        throw error;
                    }
                    throw new Error(`Contract analysis failed: ${error.message}`);
                }
            }

            async generatePDF(analysis) {
                return new Promise((resolve, reject) => {
                    try {
                        // Create new jsPDF instance
                        const { jsPDF } = window.jspdf;
                        const doc = new jsPDF();
                        
                        let yPosition = 20;
                        const pageHeight = doc.internal.pageSize.height;
                        const margin = 20;
                        const lineHeight = 7;

                        // Helper function to add text with page break handling
                        const addText = (text, x = margin, y = yPosition, options = {}) => {
                            const fontSize = options.fontSize || 11;
                            const isBold = options.isBold || false;
                            const isTitle = options.isTitle || false;
                            
                            doc.setFontSize(fontSize);
                            if (isBold || isTitle) {
                                doc.setFont(undefined, 'bold');
                            } else {
                                doc.setFont(undefined, 'normal');
                            }

                            const maxWidth = 170; // Max width for text
                            const lines = doc.splitTextToSize(text, maxWidth);
                            
                            lines.forEach(line => {
                                if (yPosition > pageHeight - margin) {
                                    doc.addPage();
                                    yPosition = margin;
                                }
                                doc.text(line, x, yPosition);
                                yPosition += lineHeight;
                            });
                            
                            return yPosition;
                        };

                        // Title
                        yPosition = addText('CLAUSE RISK & COMPLIANCE SUMMARY', margin, yPosition, {
                            fontSize: 16, isBold: true, isTitle: true
                        });
                        yPosition += 10;

                        // I. Contract Overview
                        yPosition = addText('I. CONTRACT OVERVIEW', margin, yPosition, {
                            fontSize: 14, isBold: true
                        });
                        yPosition += 5;

                        if (analysis.contract_overview) {
                            Object.entries(analysis.contract_overview).forEach(([key, value]) => {
                                if (value && value.toString().trim()) {
                                    const text = `${key}: ${value}`;
                                    yPosition = addText(text, margin, yPosition, { fontSize: 10 });
                                }
                            });
                        }
                        yPosition += 5;

                        // II. Administrative & Commercial Terms
                        if (analysis.administrative_and_commercial_terms &&
                            Object.keys(analysis.administrative_and_commercial_terms).length > 0) {
                            doc.addPage();
                            yPosition = margin;
                            
                            yPosition = addText('II. ADMINISTRATIVE & COMMERCIAL TERMS', margin, yPosition, {
                                fontSize: 14, isBold: true
                            });
                            yPosition += 5;

                            Object.entries(analysis.administrative_and_commercial_terms).forEach(([section, data]) => {
                                if (data && typeof data === 'object') {
                                    yPosition = addText(section.replace(/_/g, ' ').toUpperCase(),
                                        margin, yPosition, { fontSize: 12, isBold: true });
                                    yPosition += 3;

                                    if (data.Clause_Language) {
                                        yPosition = addText(`Clause Language: ${data.Clause_Language}`,
                                            margin + 5, yPosition, { fontSize: 9 });
                                    }
                                    if (data.Clause_Summary) {
                                        yPosition = addText(`Summary: ${data.Clause_Summary}`,
                                            margin + 5, yPosition, { fontSize: 9 });
                                    }
                                    if (data.Risk_Triggers_Identified && data.Risk_Triggers_Identified.length > 0) {
                                        yPosition = addText(`Risk Triggers: ${data.Risk_Triggers_Identified.join(', ')}`,
                                            margin + 5, yPosition, { fontSize: 9 });
                                    }
                                    yPosition += 3;
                                }
                            });
                        }

                        // III. Technical & Performance Terms
                        if (analysis.technical_and_performance_terms &&
                            Object.keys(analysis.technical_and_performance_terms).length > 0) {
                            doc.addPage();
                            yPosition = margin;
                            
                            yPosition = addText('III. TECHNICAL & PERFORMANCE TERMS', margin, yPosition, {
                                fontSize: 14, isBold: true
                            });
                            yPosition += 5;

                            Object.entries(analysis.technical_and_performance_terms).forEach(([section, data]) => {
                                if (data && typeof data === 'object') {
                                    yPosition = addText(section.replace(/_/g, ' ').toUpperCase(),
                                        margin, yPosition, { fontSize: 12, isBold: true });
                                    yPosition += 3;

                                    if (data.Clause_Language) {
                                        yPosition = addText(`Clause Language: ${data.Clause_Language}`,
                                            margin + 5, yPosition, { fontSize: 9 });
                                    }
                                    if (data.Clause_Summary) {
                                        yPosition = addText(`Summary: ${data.Clause_Summary}`,
                                            margin + 5, yPosition, { fontSize: 9 });
                                    }
                                    yPosition += 3;
                                }
                            });
                        }

                        // IV. Legal Risk & Enforcement
                        if (analysis.legal_risk_and_enforcement &&
                            Object.keys(analysis.legal_risk_and_enforcement).length > 0) {
                            doc.addPage();
                            yPosition = margin;
                            
                            yPosition = addText('IV. LEGAL RISK & ENFORCEMENT', margin, yPosition, {
                                fontSize: 14, isBold: true
                            });
                            yPosition += 5;

                            Object.entries(analysis.legal_risk_and_enforcement).forEach(([section, data]) => {
                                if (data && typeof data === 'object') {
                                    yPosition = addText(section.replace(/_/g, ' ').toUpperCase(),
                                        margin, yPosition, { fontSize: 12, isBold: true });
                                    yPosition += 3;

                                    if (data.Clause_Language) {
                                        yPosition = addText(`Clause Language: ${data.Clause_Language}`,
                                            margin + 5, yPosition, { fontSize: 9 });
                                    }
                                    if (data.Clause_Summary) {
                                        yPosition = addText(`Summary: ${data.Clause_Summary}`,
                                            margin + 5, yPosition, { fontSize: 9 });
                                    }
                                    yPosition += 3;
                                }
                            });
                        }

                        // V. Regulatory & Compliance Terms
                        if (analysis.regulatory_and_compliance_terms &&
                            Object.keys(analysis.regulatory_and_compliance_terms).length > 0) {
                            doc.addPage();
                            yPosition = margin;
                            
                            yPosition = addText('V. REGULATORY & COMPLIANCE TERMS', margin, yPosition, {
                                fontSize: 14, isBold: true
                            });
                            yPosition += 5;

                            Object.entries(analysis.regulatory_and_compliance_terms).forEach(([section, data]) => {
                                if (data && typeof data === 'object') {
                                    yPosition = addText(section.replace(/_/g, ' ').toUpperCase(),
                                        margin, yPosition, { fontSize: 12, isBold: true });
                                    yPosition += 3;

                                    if (data.Clause_Language) {
                                        yPosition = addText(`Clause Language: ${data.Clause_Language}`,
                                            margin + 5, yPosition, { fontSize: 9 });
                                    }
                                    if (data.Clause_Summary) {
                                        yPosition = addText(`Summary: ${data.Clause_Summary}`,
                                            margin + 5, yPosition, { fontSize: 9 });
                                    }
                                    yPosition += 3;
                                }
                            });
                        }

                        // VI. Data, Technology & Deliverables
                        if (analysis.data_technology_and_deliverables &&
                            Object.keys(analysis.data_technology_and_deliverables).length > 0) {
                            doc.addPage();
                            yPosition = margin;
                            
                            yPosition = addText('VI. DATA, TECHNOLOGY & DELIVERABLES', margin, yPosition, {
                                fontSize: 14, isBold: true
                            });
                            yPosition += 5;

                            Object.entries(analysis.data_technology_and_deliverables).forEach(([section, data]) => {
                                if (data && typeof data === 'object') {
                                    yPosition = addText(section.replace(/_/g, ' ').toUpperCase(),
                                        margin, yPosition, { fontSize: 12, isBold: true });
                                    yPosition += 3;

                                    if (data.Clause_Language) {
                                        yPosition = addText(`Clause Language: ${data.Clause_Language}`,
                                            margin + 5, yPosition, { fontSize: 9 });
                                    }
                                    if (data.Clause_Summary) {
                                        yPosition = addText(`Summary: ${data.Clause_Summary}`,
                                            margin + 5, yPosition, { fontSize: 9 });
                                    }
                                    yPosition += 3;
                                }
                            });
                        }

                        // VII. Supplemental Operational Risks
                        if (analysis.supplemental_operational_risks &&
                            Array.isArray(analysis.supplemental_operational_risks) &&
                            analysis.supplemental_operational_risks.length > 0) {
                            doc.addPage();
                            yPosition = margin;
                            
                            yPosition = addText('VII. SUPPLEMENTAL OPERATIONAL RISKS', margin, yPosition, {
                                fontSize: 14, isBold: true
                            });
                            yPosition += 5;

                            analysis.supplemental_operational_risks.forEach((risk, index) => {
                                if (risk && typeof risk === 'object') {
                                    yPosition = addText(`Supplemental Risk ${index + 1}`,
                                        margin, yPosition, { fontSize: 12, isBold: true });
                                    yPosition += 3;

                                    if (risk.Clause_Language) {
                                        yPosition = addText(`Clause Language: ${risk.Clause_Language}`,
                                            margin + 5, yPosition, { fontSize: 9 });
                                    }
                                    if (risk.Clause_Summary) {
                                        yPosition = addText(`Summary: ${risk.Clause_Summary}`,
                                            margin + 5, yPosition, { fontSize: 9 });
                                    }
                                    yPosition += 3;
                                }
                            });
                        }

                        // VIII. Final Analysis
                        if (analysis.final_analysis &&
                            analysis.final_analysis["Final Redline Risk Summary and Recommendations"]) {
                            doc.addPage();
                            yPosition = margin;
                            
                            yPosition = addText('VIII. FINAL ANALYSIS', margin, yPosition, {
                                fontSize: 14, isBold: true
                            });
                            yPosition += 5;

                            yPosition = addText('Final Redline Risk Summary and Recommendations',
                                margin, yPosition, { fontSize: 12, isBold: true });
                            yPosition += 5;

                            analysis.final_analysis["Final Redline Risk Summary and Recommendations"]
                                .forEach((item, index) => {
                                    if (item && typeof item === 'object') {
                                        if (item["Risk Area"]) {
                                            yPosition = addText(`Risk Area: ${item["Risk Area"]}`,
                                                margin, yPosition, { fontSize: 10, isBold: true });
                                        }
                                        if (item["Risk Summary"]) {
                                            yPosition = addText(`Risk Summary: ${item["Risk Summary"]}`,
                                                margin + 5, yPosition, { fontSize: 9 });
                                        }
                                        if (item["APS Redline Position"]) {
                                            yPosition = addText(`APS Redline Position: ${item["APS Redline Position"]}`,
                                                margin + 5, yPosition, { fontSize: 9 });
                                        }
                                        yPosition += 3;
                                    }
                                });
                        }

                        // Footer
                        doc.setFontSize(8);
                        doc.setFont(undefined, 'normal');
                        const footerText = `Generated on ${new Date().toLocaleString()} | Contract Analysis Tool v1.0`;
                        doc.text(footerText, margin, pageHeight - 10);

                        // Save PDF
                        const filename = `contract_analysis_${new Date().toISOString().split('T')[0]}.pdf`;
                        doc.save(filename);
                        
                        this.generatedPDFFilename = filename;
                        resolve();

                    } catch (error) {
                        reject(new Error(`PDF generation failed: ${error.message}`));
                    }
                });
            }

            generatePDFContent(analysis) {
                // Generate a text-based report similar to the PDF structure
                let content = 'CONTRACT ANALYSIS REPORT\n';
                content += '========================\n\n';

                // Contract Overview
                content += 'I. CONTRACT OVERVIEW\n';
                content += '--------------------\n';
                if (analysis.contract_overview) {
                    Object.entries(analysis.contract_overview).forEach(([key, value]) => {
                        content += `${key}: ${value}\n`;
                    });
                }
                content += '\n';

                // Final Analysis
                content += 'VIII. FINAL ANALYSIS\n';
                content += '-------------------\n';
                if (analysis.final_analysis?.["Final Redline Risk Summary and Recommendations"]) {
                    analysis.final_analysis["Final Redline Risk Summary and Recommendations"].forEach((item, index) => {
                        content += `${index + 1}. Risk Area: ${item["Risk Area"]}\n`;
                        content += `   Risk Summary: ${item["Risk Summary"]}\n`;
                        content += `   APS Redline Position: ${item["APS Redline Position"]}\n\n`;
                    });
                }

                content += `\nGenerated on: ${new Date().toLocaleString()}\n`;
                return content;
            }

            showStatus(message, type) {
                const statusElement = document.getElementById('status-message');
                statusElement.textContent = message;
                statusElement.className = `status ${type}`;
                statusElement.style.display = 'block';
            }

            showProgress(percentage, text) {
                const progressContainer = document.getElementById('progress-container');
                const progressFill = document.getElementById('progress-fill');
                const progressText = document.getElementById('progress-text');

                progressContainer.style.display = 'block';
                progressFill.style.width = `${percentage}%`;
                progressText.textContent = text;
            }

            showDownloadSection() {
                document.getElementById('download-section').style.display = 'block';
                document.getElementById('progress-container').style.display = 'none';
            }

            downloadPDF() {
                if (this.generatedPDFBlob) {
                    const url = URL.createObjectURL(this.generatedPDFBlob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = this.generatedPDFFilename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    // Clean up
                    this.cleanup();
                }
            }

            cleanup() {
                // Remove temporary files and reset state
                this.files = [];
                this.generatedPDFBlob = null;
                this.generatedPDFFilename = null;
                
                // Clear UI elements
                document.getElementById('file-list').innerHTML = '';
                document.getElementById('download-section').style.display = 'none';
                document.getElementById('progress-container').style.display = 'none';
                
                // Clear any existing status messages
                this.clearStatus();
                
                // Reset form elements
                document.getElementById('api-key').value = '';
                document.getElementById('custom-template').value = '';
                
                // Update drop zone text
                const dropZoneText = document.querySelector('.drop-zone-text');
                const dropZoneSubtext = document.querySelector('.drop-zone-subtext');
                if (dropZoneText) dropZoneText.textContent = 'Drop contract files here';
                if (dropZoneSubtext) dropZoneSubtext.textContent = 'or click to browse files';
                
                console.log('Application state cleaned up successfully');
            }

            // Enhanced error handling for various scenarios
            handleError(error, context) {
                console.error(`Error in ${context}:`, error);
                
                let userMessage = error.message;
                
                // Provide more user-friendly error messages
                if (error.message.includes('API error')) {
                    if (error.message.includes('401')) {
                        userMessage = 'Invalid API key. Please check your OpenAI API key.';
                    } else if (error.message.includes('429')) {
                        userMessage = 'API rate limit exceeded. Please try again later.';
                    } else if (error.message.includes('500')) {
                        userMessage = 'OpenAI server error. Please try again later.';
                    }
                } else if (error.message.includes('PDF text extraction failed')) {
                    userMessage = 'Failed to extract text from PDF. The file may be corrupted or password-protected.';
                } else if (error.message.includes('Failed to read')) {
                    userMessage = 'Failed to read one or more files. Please check file formats and try again.';
                } else if (error.message.includes('network') || error.message.includes('fetch')) {
                    userMessage = 'Network error. Please check your internet connection and try again.';
                }
                
                this.showStatus(userMessage, 'error');
            }

            // Add keyboard shortcuts for better UX
            addKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    // Ctrl/Cmd + K to focus API key input
                    if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                        e.preventDefault();
                        document.getElementById('api-key').focus();
                    }
                    
                    // Ctrl/Cmd + O to trigger file selection
                    if ((e.ctrlKey || e.metaKey) && e.key === 'o') {
                        e.preventDefault();
                        document.getElementById('drop-zone').click();
                    }
                    
                    // Escape key to clear status messages
                    if (e.key === 'Escape') {
                        this.clearStatus();
                    }
                });
            }
        }

        // Initialize the application
        const analyzer = new ContractAnalyzer();
        
        // Add keyboard shortcuts after initialization
        analyzer.addKeyboardShortcuts();
    </script>
</body>
</html>