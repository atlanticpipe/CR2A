"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@openai";
exports.ids = ["vendor-chunks/@openai"];
exports.modules = {

/***/ "(ssr)/./node_modules/@openai/chatkit-react/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@openai/chatkit-react/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatKit: () => (/* binding */ ChatKit),\n/* harmony export */   useChatKit: () => (/* binding */ useChatKit)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n// src/ChatKit.tsx\n\n\nvar ChatKit = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  function ChatKit2({ control, ...htmlProps }, forwardedRef) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n      const el = ref.current;\n      if (!el) return;\n      if (customElements.get(\"openai-chatkit\")) {\n        el.setOptions(control.options);\n        return;\n      }\n      let active = true;\n      customElements.whenDefined(\"openai-chatkit\").then(() => {\n        if (active) {\n          el.setOptions(control.options);\n        }\n      });\n      return () => {\n        active = false;\n      };\n    }, [control.options]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      \"openai-chatkit\",\n      {\n        ref: (chatKit) => {\n          ref.current = chatKit;\n          control.setInstance(chatKit);\n          if (typeof forwardedRef === \"function\") {\n            forwardedRef(chatKit);\n          } else if (forwardedRef) {\n            forwardedRef.current = chatKit;\n          }\n          if (!ref.current) {\n            return;\n          }\n          const events = {\n            \"chatkit.error\": \"onError\",\n            \"chatkit.response.end\": \"onResponseEnd\",\n            \"chatkit.response.start\": \"onResponseStart\",\n            \"chatkit.log\": \"onLog\",\n            \"chatkit.thread.change\": \"onThreadChange\",\n            \"chatkit.thread.load.start\": \"onThreadLoadStart\",\n            \"chatkit.thread.load.end\": \"onThreadLoadEnd\"\n          };\n          const eventNames = Object.keys(events);\n          for (const event of eventNames) {\n            ref.current.addEventListener(event, (e) => {\n              const handler = control.handlers[events[event]];\n              if (typeof handler === \"function\") {\n                handler(e.detail);\n              }\n            });\n          }\n        },\n        ...htmlProps\n      }\n    );\n  }\n);\n\n// src/useChatKit.ts\n\n\n// src/useStableOptions.ts\n\nfunction isPlainObjectOrArray(obj) {\n  return obj !== null && typeof obj === \"object\" && [null, Object.prototype].includes(Object.getPrototypeOf(obj)) || Array.isArray(obj);\n}\nfunction deepEqualIgnoringFns(a, b, seen = /* @__PURE__ */ new WeakMap()) {\n  if (Object.is(a, b)) return true;\n  if (typeof a === \"function\" && typeof b === \"function\") {\n    return typeof a === typeof b;\n  }\n  if (!isPlainObjectOrArray(a) || !isPlainObjectOrArray(b)) {\n    return false;\n  }\n  const mapped = seen.get(a);\n  if (mapped && mapped === b) return true;\n  seen.set(a, b);\n  if (Array.isArray(a) || Array.isArray(b)) {\n    if (!Array.isArray(a) || !Array.isArray(b) || a.length !== b.length)\n      return false;\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqualIgnoringFns(a[i], b[i], seen)) return false;\n    }\n    return true;\n  }\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n  if (aKeys.length !== bKeys.length) return false;\n  for (let i = 0; i < aKeys.length; i++) {\n    const k = aKeys[i];\n    if (!Object.prototype.hasOwnProperty.call(b, k)) return false;\n    const av = a[k];\n    const bv = b[k];\n    if (!deepEqualIgnoringFns(av, bv, seen)) return false;\n  }\n  return true;\n}\nfunction withLatestFunctionWrappers(ref) {\n  const path = [];\n  const getByPath = (root, p) => p.reduce((acc, k) => acc == null ? acc : acc[k], root);\n  const wrap = (parentPath, key) => {\n    return (...args) => {\n      const latestParent = getByPath(ref.current, parentPath);\n      const latestFn = latestParent?.[key];\n      if (typeof latestFn === \"function\") {\n        return latestFn.apply(latestParent, args);\n      }\n    };\n  };\n  const visit = (v) => {\n    if (typeof v === \"function\") {\n      const key = path[path.length - 1];\n      const parentPath = path.slice(0, -1);\n      return wrap(parentPath, key);\n    }\n    if (Array.isArray(v)) {\n      const base = path.length;\n      const out = new Array(v.length);\n      for (let i = 0; i < v.length; i++) {\n        path[base] = i;\n        out[i] = visit(v[i]);\n      }\n      path.length = base;\n      return out;\n    }\n    if (v && typeof v === \"object\") {\n      const base = path.length;\n      const out = {};\n      for (const k of Object.keys(v)) {\n        path[base] = k;\n        out[k] = visit(v[k]);\n      }\n      path.length = base;\n      return out;\n    }\n    return v;\n  };\n  return visit(ref.current);\n}\nfunction useStableOptions(options) {\n  const latestOptions = react__WEBPACK_IMPORTED_MODULE_0__.useRef(options);\n  latestOptions.current = options;\n  const cache = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  if (!cache.current || !deepEqualIgnoringFns(cache.current.snapshot, options)) {\n    cache.current = {\n      snapshot: options,\n      shaped: withLatestFunctionWrappers(latestOptions)\n    };\n  }\n  return cache.current.shaped;\n}\n\n// src/useChatKit.ts\nvar CHATKIT_METHOD_NAMES = Object.freeze([\n  \"focusComposer\",\n  \"setThreadId\",\n  \"sendUserMessage\",\n  \"setComposerValue\",\n  \"fetchUpdates\",\n  \"sendCustomAction\"\n]);\nfunction useChatKit(options) {\n  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const stableOptions = useStableOptions(options);\n  const methods = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    return CHATKIT_METHOD_NAMES.reduce((acc, key) => {\n      acc[key] = (...args) => {\n        if (!ref.current) {\n          console.warn(\"ChatKit element is not mounted\");\n          return;\n        }\n        return ref.current[key](...args);\n      };\n      return acc;\n    }, {});\n  }, []);\n  const setInstance = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (instance) => {\n      ref.current = instance;\n    },\n    []\n  );\n  const control = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    const options2 = {};\n    const handlers = {};\n    for (const [key, value] of Object.entries(stableOptions)) {\n      if (/^on[A-Z]/.test(key) && key !== \"onClientTool\") {\n        handlers[key] = value;\n      } else {\n        options2[key] = value;\n      }\n    }\n    return {\n      setInstance,\n      options: options2,\n      handlers\n    };\n  }, [stableOptions, setInstance]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => ({ ...methods, control, ref }),\n    [methods, control]\n  );\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9wZW5haS9jaGF0a2l0LXJlYWN0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQytCO0FBQ1M7QUFDeEMsY0FBYyw2Q0FBZ0I7QUFDOUIsc0JBQXNCLHVCQUF1QjtBQUM3QyxnQkFBZ0IseUNBQVk7QUFDNUIsSUFBSSxrREFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkJBQTJCLHNEQUFHO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ2dDOztBQUVoQztBQUMyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUNBQWE7QUFDckM7QUFDQSxnQkFBZ0IseUNBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUNBQWE7QUFDM0I7QUFDQSxrQkFBa0IsMENBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1QsR0FBRztBQUNILHNCQUFzQiw4Q0FBa0I7QUFDeEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0JBQWtCLDBDQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxTQUFTLDBDQUFjO0FBQ3ZCLGFBQWEsMEJBQTBCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUlFIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG1jYXJyb2xsXFxPbmVEcml2ZSAtIEF0bGFudGljIFBpcGUgU2VydmljZXMsIExMQ1xcRGVza3RvcFxcY3IyYVxcQ1IyQVxcbm9kZV9tb2R1bGVzXFxAb3BlbmFpXFxjaGF0a2l0LXJlYWN0XFxkaXN0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvQ2hhdEtpdC50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgQ2hhdEtpdCA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIGZ1bmN0aW9uIENoYXRLaXQyKHsgY29udHJvbCwgLi4uaHRtbFByb3BzIH0sIGZvcndhcmRlZFJlZikge1xuICAgIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3QgZWwgPSByZWYuY3VycmVudDtcbiAgICAgIGlmICghZWwpIHJldHVybjtcbiAgICAgIGlmIChjdXN0b21FbGVtZW50cy5nZXQoXCJvcGVuYWktY2hhdGtpdFwiKSkge1xuICAgICAgICBlbC5zZXRPcHRpb25zKGNvbnRyb2wub3B0aW9ucyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBhY3RpdmUgPSB0cnVlO1xuICAgICAgY3VzdG9tRWxlbWVudHMud2hlbkRlZmluZWQoXCJvcGVuYWktY2hhdGtpdFwiKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgIGVsLnNldE9wdGlvbnMoY29udHJvbC5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBhY3RpdmUgPSBmYWxzZTtcbiAgICAgIH07XG4gICAgfSwgW2NvbnRyb2wub3B0aW9uc10pO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgXCJvcGVuYWktY2hhdGtpdFwiLFxuICAgICAge1xuICAgICAgICByZWY6IChjaGF0S2l0KSA9PiB7XG4gICAgICAgICAgcmVmLmN1cnJlbnQgPSBjaGF0S2l0O1xuICAgICAgICAgIGNvbnRyb2wuc2V0SW5zdGFuY2UoY2hhdEtpdCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmb3J3YXJkZWRSZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZm9yd2FyZGVkUmVmKGNoYXRLaXQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZm9yd2FyZGVkUmVmKSB7XG4gICAgICAgICAgICBmb3J3YXJkZWRSZWYuY3VycmVudCA9IGNoYXRLaXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZXZlbnRzID0ge1xuICAgICAgICAgICAgXCJjaGF0a2l0LmVycm9yXCI6IFwib25FcnJvclwiLFxuICAgICAgICAgICAgXCJjaGF0a2l0LnJlc3BvbnNlLmVuZFwiOiBcIm9uUmVzcG9uc2VFbmRcIixcbiAgICAgICAgICAgIFwiY2hhdGtpdC5yZXNwb25zZS5zdGFydFwiOiBcIm9uUmVzcG9uc2VTdGFydFwiLFxuICAgICAgICAgICAgXCJjaGF0a2l0LmxvZ1wiOiBcIm9uTG9nXCIsXG4gICAgICAgICAgICBcImNoYXRraXQudGhyZWFkLmNoYW5nZVwiOiBcIm9uVGhyZWFkQ2hhbmdlXCIsXG4gICAgICAgICAgICBcImNoYXRraXQudGhyZWFkLmxvYWQuc3RhcnRcIjogXCJvblRocmVhZExvYWRTdGFydFwiLFxuICAgICAgICAgICAgXCJjaGF0a2l0LnRocmVhZC5sb2FkLmVuZFwiOiBcIm9uVGhyZWFkTG9hZEVuZFwiXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBldmVudE5hbWVzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50TmFtZXMpIHtcbiAgICAgICAgICAgIHJlZi5jdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIChlKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBjb250cm9sLmhhbmRsZXJzW2V2ZW50c1tldmVudF1dO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoZS5kZXRhaWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC4uLmh0bWxQcm9wc1xuICAgICAgfVxuICAgICk7XG4gIH1cbik7XG5cbi8vIHNyYy91c2VDaGF0S2l0LnRzXG5pbXBvcnQgKiBhcyBSZWFjdDMgZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy91c2VTdGFibGVPcHRpb25zLnRzXG5pbXBvcnQgUmVhY3QyIGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdE9yQXJyYXkob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiBbbnVsbCwgT2JqZWN0LnByb3RvdHlwZV0uaW5jbHVkZXMoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikpIHx8IEFycmF5LmlzQXJyYXkob2JqKTtcbn1cbmZ1bmN0aW9uIGRlZXBFcXVhbElnbm9yaW5nRm5zKGEsIGIsIHNlZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSkge1xuICBpZiAoT2JqZWN0LmlzKGEsIGIpKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKHR5cGVvZiBhID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGI7XG4gIH1cbiAgaWYgKCFpc1BsYWluT2JqZWN0T3JBcnJheShhKSB8fCAhaXNQbGFpbk9iamVjdE9yQXJyYXkoYikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgbWFwcGVkID0gc2Vlbi5nZXQoYSk7XG4gIGlmIChtYXBwZWQgJiYgbWFwcGVkID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgc2Vlbi5zZXQoYSwgYik7XG4gIGlmIChBcnJheS5pc0FycmF5KGEpIHx8IEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYSkgfHwgIUFycmF5LmlzQXJyYXkoYikgfHwgYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFkZWVwRXF1YWxJZ25vcmluZ0ZucyhhW2ldLCBiW2ldLCBzZWVuKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBhS2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICBjb25zdCBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGsgPSBhS2V5c1tpXTtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBrKSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGF2ID0gYVtrXTtcbiAgICBjb25zdCBidiA9IGJba107XG4gICAgaWYgKCFkZWVwRXF1YWxJZ25vcmluZ0ZucyhhdiwgYnYsIHNlZW4pKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB3aXRoTGF0ZXN0RnVuY3Rpb25XcmFwcGVycyhyZWYpIHtcbiAgY29uc3QgcGF0aCA9IFtdO1xuICBjb25zdCBnZXRCeVBhdGggPSAocm9vdCwgcCkgPT4gcC5yZWR1Y2UoKGFjYywgaykgPT4gYWNjID09IG51bGwgPyBhY2MgOiBhY2Nba10sIHJvb3QpO1xuICBjb25zdCB3cmFwID0gKHBhcmVudFBhdGgsIGtleSkgPT4ge1xuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgY29uc3QgbGF0ZXN0UGFyZW50ID0gZ2V0QnlQYXRoKHJlZi5jdXJyZW50LCBwYXJlbnRQYXRoKTtcbiAgICAgIGNvbnN0IGxhdGVzdEZuID0gbGF0ZXN0UGFyZW50Py5ba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgbGF0ZXN0Rm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gbGF0ZXN0Rm4uYXBwbHkobGF0ZXN0UGFyZW50LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBjb25zdCB2aXNpdCA9ICh2KSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IGtleSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgICAgIHJldHVybiB3cmFwKHBhcmVudFBhdGgsIGtleSk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICBjb25zdCBiYXNlID0gcGF0aC5sZW5ndGg7XG4gICAgICBjb25zdCBvdXQgPSBuZXcgQXJyYXkodi5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhdGhbYmFzZV0gPSBpO1xuICAgICAgICBvdXRbaV0gPSB2aXNpdCh2W2ldKTtcbiAgICAgIH1cbiAgICAgIHBhdGgubGVuZ3RoID0gYmFzZTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGlmICh2ICYmIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCBiYXNlID0gcGF0aC5sZW5ndGg7XG4gICAgICBjb25zdCBvdXQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyh2KSkge1xuICAgICAgICBwYXRoW2Jhc2VdID0gaztcbiAgICAgICAgb3V0W2tdID0gdmlzaXQodltrXSk7XG4gICAgICB9XG4gICAgICBwYXRoLmxlbmd0aCA9IGJhc2U7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICByZXR1cm4gdjtcbiAgfTtcbiAgcmV0dXJuIHZpc2l0KHJlZi5jdXJyZW50KTtcbn1cbmZ1bmN0aW9uIHVzZVN0YWJsZU9wdGlvbnMob3B0aW9ucykge1xuICBjb25zdCBsYXRlc3RPcHRpb25zID0gUmVhY3QyLnVzZVJlZihvcHRpb25zKTtcbiAgbGF0ZXN0T3B0aW9ucy5jdXJyZW50ID0gb3B0aW9ucztcbiAgY29uc3QgY2FjaGUgPSBSZWFjdDIudXNlUmVmKG51bGwpO1xuICBpZiAoIWNhY2hlLmN1cnJlbnQgfHwgIWRlZXBFcXVhbElnbm9yaW5nRm5zKGNhY2hlLmN1cnJlbnQuc25hcHNob3QsIG9wdGlvbnMpKSB7XG4gICAgY2FjaGUuY3VycmVudCA9IHtcbiAgICAgIHNuYXBzaG90OiBvcHRpb25zLFxuICAgICAgc2hhcGVkOiB3aXRoTGF0ZXN0RnVuY3Rpb25XcmFwcGVycyhsYXRlc3RPcHRpb25zKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGNhY2hlLmN1cnJlbnQuc2hhcGVkO1xufVxuXG4vLyBzcmMvdXNlQ2hhdEtpdC50c1xudmFyIENIQVRLSVRfTUVUSE9EX05BTUVTID0gT2JqZWN0LmZyZWV6ZShbXG4gIFwiZm9jdXNDb21wb3NlclwiLFxuICBcInNldFRocmVhZElkXCIsXG4gIFwic2VuZFVzZXJNZXNzYWdlXCIsXG4gIFwic2V0Q29tcG9zZXJWYWx1ZVwiLFxuICBcImZldGNoVXBkYXRlc1wiLFxuICBcInNlbmRDdXN0b21BY3Rpb25cIlxuXSk7XG5mdW5jdGlvbiB1c2VDaGF0S2l0KG9wdGlvbnMpIHtcbiAgY29uc3QgcmVmID0gUmVhY3QzLnVzZVJlZihudWxsKTtcbiAgY29uc3Qgc3RhYmxlT3B0aW9ucyA9IHVzZVN0YWJsZU9wdGlvbnMob3B0aW9ucyk7XG4gIGNvbnN0IG1ldGhvZHMgPSBSZWFjdDMudXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIENIQVRLSVRfTUVUSE9EX05BTUVTLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgIGFjY1trZXldID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKCFyZWYuY3VycmVudCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIkNoYXRLaXQgZWxlbWVudCBpcyBub3QgbW91bnRlZFwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZi5jdXJyZW50W2tleV0oLi4uYXJncyk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gIH0sIFtdKTtcbiAgY29uc3Qgc2V0SW5zdGFuY2UgPSBSZWFjdDMudXNlQ2FsbGJhY2soXG4gICAgKGluc3RhbmNlKSA9PiB7XG4gICAgICByZWYuY3VycmVudCA9IGluc3RhbmNlO1xuICAgIH0sXG4gICAgW11cbiAgKTtcbiAgY29uc3QgY29udHJvbCA9IFJlYWN0My51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBvcHRpb25zMiA9IHt9O1xuICAgIGNvbnN0IGhhbmRsZXJzID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc3RhYmxlT3B0aW9ucykpIHtcbiAgICAgIGlmICgvXm9uW0EtWl0vLnRlc3Qoa2V5KSAmJiBrZXkgIT09IFwib25DbGllbnRUb29sXCIpIHtcbiAgICAgICAgaGFuZGxlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9uczJba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2V0SW5zdGFuY2UsXG4gICAgICBvcHRpb25zOiBvcHRpb25zMixcbiAgICAgIGhhbmRsZXJzXG4gICAgfTtcbiAgfSwgW3N0YWJsZU9wdGlvbnMsIHNldEluc3RhbmNlXSk7XG4gIHJldHVybiBSZWFjdDMudXNlTWVtbyhcbiAgICAoKSA9PiAoeyAuLi5tZXRob2RzLCBjb250cm9sLCByZWYgfSksXG4gICAgW21ldGhvZHMsIGNvbnRyb2xdXG4gICk7XG59XG5leHBvcnQge1xuICBDaGF0S2l0LFxuICB1c2VDaGF0S2l0XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@openai/chatkit-react/dist/index.js\n");

/***/ })

};
;