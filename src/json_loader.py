"""
Contract JSON Loader Module

Handles loading and validation of contract analysis JSON files.
"""

import json
import logging
from pathlib import Path
from typing import Dict, Any, List

from src.error_handler import ErrorHandler


logger = logging.getLogger(__name__)


class ValidationError(Exception):
    """Raised when JSON schema validation fails."""
    pass


class ContractJSONLoader:
    """
    Loads and validates contract analysis JSON files.
    
    This class handles reading JSON files generated by ContractAnalysisCLI.exe,
    parsing the content, and validating that the data conforms to the expected
    contract analysis schema.
    """
    
    # Expected top-level fields in contract analysis JSON
    EXPECTED_FIELDS = {
        "parties": dict,
        "terms": dict,
        "risks": list,
        "dates": dict,
        "financial_terms": dict,
    }
    
    def __init__(self):
        """Initialize the JSON loader."""
        self.error_handler = ErrorHandler()
        logger.debug("ContractJSONLoader initialized")
    
    def load_file(self, file_path: str) -> Dict[str, Any]:
        """
        Load and parse Analysis_JSON file.
        
        Args:
            file_path: Path to JSON file
            
        Returns:
            Parsed contract data dictionary
            
        Raises:
            FileNotFoundError: If file doesn't exist
            json.JSONDecodeError: If file is not valid JSON
            ValidationError: If JSON doesn't match expected schema
        """
        logger.info("Loading contract JSON file: %s", file_path)
        
        try:
            # Convert to Path object for better path handling
            path = Path(file_path)
            
            # Check if file exists
            if not path.exists():
                logger.error("File not found: %s", file_path)
                raise FileNotFoundError(f"Contract analysis file not found: {file_path}")
            
            # Check if it's a file (not a directory)
            if not path.is_file():
                logger.error("Path is not a file: %s", file_path)
                raise FileNotFoundError(f"Path is not a file: {file_path}")
            
            # Read and parse JSON file
            with open(path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            logger.debug("JSON file parsed successfully")
            
            # Validate schema
            if not self.validate_schema(data):
                # Build detailed error message
                if not isinstance(data, dict):
                    error_message = (
                        "Invalid contract analysis format: Root element must be a JSON object (dictionary).\n\n"
                        "Expected format:\n"
                        "{\n"
                        '  "parties": {...},\n'
                        '  "terms": {...},\n'
                        '  "risks": [...],\n'
                        '  "dates": {...},\n'
                        '  "financial_terms": {...}\n'
                        "}"
                    )
                else:
                    # Check for missing fields and invalid types
                    missing_fields = []
                    invalid_types = []
                    
                    for field_name, expected_type in self.EXPECTED_FIELDS.items():
                        if field_name not in data:
                            missing_fields.append(field_name)
                        elif not isinstance(data[field_name], expected_type):
                            invalid_types.append(
                                f"{field_name} (expected {expected_type.__name__}, "
                                f"got {type(data[field_name]).__name__})"
                            )
                    
                    error_parts = ["This JSON file does not match the expected Contract_Analyzer schema.\n"]
                    
                    if missing_fields:
                        error_parts.append(f"\nMissing required fields: {', '.join(missing_fields)}")
                    
                    if invalid_types:
                        error_parts.append(f"\nInvalid field types: {', '.join(invalid_types)}")
                    
                    error_parts.append("\n\nExpected schema:")
                    error_parts.append("• parties (object): Contract parties information")
                    error_parts.append("• terms (object): Contract terms and conditions")
                    error_parts.append("• risks (array): List of identified risks")
                    error_parts.append("• dates (object): Important dates and deadlines")
                    error_parts.append("• financial_terms (object): Monetary information")
                    
                    error_parts.append("\n\nPlease ensure this file was generated by ContractAnalysisCLI.exe")
                    
                    error_message = "\n".join(error_parts)
                
                logger.error("Schema validation failed: %s", error_message)
                raise ValidationError(error_message)
            
            logger.info("Contract JSON loaded and validated successfully")
            return data
            
        except (FileNotFoundError, json.JSONDecodeError, ValidationError):
            # Re-raise these expected errors
            raise
            
        except UnicodeDecodeError as e:
            logger.error("Unicode decode error in file %s: %s", file_path, e)
            # Use error handler to log and provide user-friendly message
            error_response = self.error_handler.handle_error(e, "file_loading")
            raise ValidationError(error_response.message)
            
        except Exception as e:
            logger.error("Unexpected error loading file %s: %s", file_path, e)
            # Use error handler for unexpected errors
            error_response = self.error_handler.handle_error(e, "file_loading")
            raise Exception(error_response.message)
    
    def validate_schema(self, data: Dict[str, Any]) -> bool:
        """
        Validate that JSON contains expected contract fields.
        
        Args:
            data: Parsed JSON data
            
        Returns:
            True if valid, False otherwise
        """
        if not isinstance(data, dict):
            logger.warning("Root element is not a dictionary")
            return False
        
        # Check for expected fields and their types
        missing_fields = []
        invalid_types = []
        
        for field_name, expected_type in self.EXPECTED_FIELDS.items():
            if field_name not in data:
                missing_fields.append(field_name)
            elif not isinstance(data[field_name], expected_type):
                invalid_types.append(
                    f"{field_name} (expected {expected_type.__name__}, "
                    f"got {type(data[field_name]).__name__})"
                )
        
        if missing_fields or invalid_types:
            logger.warning("Schema validation failed: missing_fields=%s, invalid_types=%s", 
                          missing_fields, invalid_types)
            return False
        
        logger.debug("Schema validation passed")
        return True
    
    def get_schema_info(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Extract schema information from loaded contract data.
        
        Args:
            data: Parsed contract JSON data
            
        Returns:
            Dictionary containing schema metadata
        """
        schema_info = {
            "has_parties": "parties" in data and bool(data["parties"]),
            "has_terms": "terms" in data and bool(data["terms"]),
            "risk_count": len(data.get("risks", [])),
            "has_dates": "dates" in data and bool(data["dates"]),
            "has_financial_terms": "financial_terms" in data and bool(data["financial_terms"]),
            "total_fields": len(data),
        }
        
        logger.debug("Schema info: %s", schema_info)
        return schema_info
    
    def check_schema_compatibility(self, data: Dict[str, Any]) -> tuple[bool, List[str]]:
        """
        Check schema compatibility and return detailed warnings.
        
        Args:
            data: Parsed contract JSON data
            
        Returns:
            Tuple of (is_compatible, list_of_warnings)
        """
        warnings = []
        
        # Check for empty required fields
        if "parties" in data and not data["parties"]:
            warnings.append("Parties field is empty")
        
        if "terms" in data and not data["terms"]:
            warnings.append("Terms field is empty")
        
        if "risks" in data and len(data["risks"]) == 0:
            warnings.append("No risks identified in contract")
        
        if "dates" in data and not data["dates"]:
            warnings.append("Dates field is empty")
        
        if "financial_terms" in data and not data["financial_terms"]:
            warnings.append("Financial terms field is empty")
        
        # Check for unexpected extra fields (informational only)
        expected_fields = set(self.EXPECTED_FIELDS.keys())
        actual_fields = set(data.keys())
        extra_fields = actual_fields - expected_fields
        
        if extra_fields:
            warnings.append(f"Additional fields found: {', '.join(extra_fields)}")
        
        is_compatible = len(warnings) == 0 or all("Additional fields" in w for w in warnings)
        
        logger.debug("Schema compatibility check: compatible=%s, warnings=%s", is_compatible, warnings)
        return is_compatible, warnings
